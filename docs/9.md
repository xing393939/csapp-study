### 并行和同步

#### 概念
1. 并行程序常见的错误有三：竞争条件、死锁和活锁
1. 并行的策略根据系统机制的层级和实现方式，有下面三大类方法：
1. 基于进程
  * 内核自动管理多个逻辑流
  * 每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）
1. 基于事件
  * 由程序员手动控制多个逻辑流
  * 所有的逻辑流共享同一个地址空间
  * 这个技术称为 I/O multiplexing
1. 基于线程
  * 内核自动管理多个逻辑流
  * 每个线程共享地址空间
  * 属于基于进程和基于事件的混合体

#### 以Web服务器为例
1. 基于进程：是建立了连接之后才开始并行，连接的建立还是串行的。
  * 服务器在 accept 连接后 fork 一个子进程来处理客户端的请求
  * 必须回收僵尸进程，来避免严重的内存泄露
  * 不同进程之间不共享数据
  * 缺点：带来了额外的进程管理开销，并且进程间通讯不便，需要使用 IPC
1. 基于事件：
  * 可以利用调试器进行单步调试（其他的方法因为并行的缘故基本没办法调试）
  * 不会有进程/线程控制的开销
  * 缺点：代码的逻辑复杂度会比较高，很难进行精细度比较高的并行
1. 基于线程，线程和进程的区别：
  * 相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。
  * 不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）
  * Pthreads API 是一个线程库（POSIX Threads）
  * Pthreads API 中大致共有 100 个函数调用，全都以 pthread_ 开头，并可以分为四类：
    1. 线程管理，例如创建线程，等待(join)线程，查询线程状态等。
    1. Mutex：创建、摧毁、锁定、解锁、设置属性等操作
    1. 条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作
    1. 使用了读写锁的线程间的同步管理
  * POSIX 的 Semaphore API 可以和 Pthreads 协同工作，但这并不是 Pthreads 的标准，这部分API是以 sem_ 打头


