### 虚拟内存与动态内存分配

#### 虚拟内存的三个角色
1. 作为缓存工具
  * VP（Virtual Page）
  * PP（Physical Page）
  * 页表（Page Table）
  * 页表项（Page Table Entry)，简称PTE，里面会有标志位（是否已缓存、可读、可写、可执行）
1. 作为内存管理工具
1. 作为内存保护工具

#### 地址翻译
1. 术语：
  * TLB（Translation Lookaside Buffer），MMU和内存之间的缓存
  * 虚拟地址(VA, Virtual Address)，元素有
    1. TLBT: TLB 的标签(tag)
    1. TLBI: TLB 的索引值
    1. VPN: 虚拟页编号
    1. VPO: 虚拟页偏移量
  * 物理地址(PA, Physical Address)
    1. PPN: 物理页编号
    1. PPO: 物理页偏移量（与 VPO 的值相同）
1. CPU获取数据的流程
  1. CPU发送VA给MMU
  1. MMU通过TLBT和TLBI获取PTE，先从TLB取，没有就去内存取
  1. 得到PTE
  1. 通过PTE可知数据是否在内存
  1. 数据在内存，直接读内存；数据不在内存，先从硬盘读取，存内存并返回
1. 地址翻译实例，假定
  * 14 位的虚拟地址，高位13~6是VPN，5~0是VPO；高位13~8是TLBT，7~6是TLBI
  * 12 位的物理地址，高位11~6是PPN，5~0是PPO
  * 页大小为 64 字节
  * TLB的配置：4个集合，每个集合4条记录

#### 内存分配器有两种类型
1. 显式分配器：应用分配并且回收空间（C 语言中的 malloc 和 free）
1. 隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）

#### 内存分配器
1. 性能指标：
  * 提高吞吐量：假设在 10 秒中之内进行了 5000 次 malloc 和 5000 次 free 调用，那么吞吐量是 1000 operations/second
  * 最大的内存利用率。影响内存利用率的主要因素就是『内存碎片』，分为内部碎片和外部碎片两种：
    1. 内部碎片：由于字节对齐引起的碎片
    1. 外部碎片：内存中有足够的空间，但是空间不连续，所以成为了碎片
1. 实现一个高效的内存分配算法需要考虑的问题：
  * 给定一个指针，我们如何知道需要释放多少内存？
  * 如何记录未分配的块？
  * 实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？
  * 如果有多个区域满足条件，如何选择？
  * 释放空间之后如何进行记录？
1. 垃圾回收：就是我们不再需要显式释放所申请内存空间了
1. 内存陷阱，关于内存的使用需要注意避免以下问题：
  * 解引用错误指针
  * 读取未初始化的内存
  * 覆盖内存
  * 引用不存在的变量
  * 多次释放同一个块
  * 引用已释放的块
  * 释放块失败

