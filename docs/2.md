### 机器指令与程序优化

#### 汇编
1. 通用寄存器(64 位处理器设计)
  * %rax(%eax) 用于做累加
  * %rcx(%ecx) 用于计数
  * %rdx(%edx) 用于保存数据
  * %rbx(%ebx) 用于做内存查找的基础地址
  * %rsi(%esi) 用于保存源索引值
  * %rdi(%edi) 用于保存目标索引值
1. %rsp(%esp) 和 %rbp(%ebp) 则是作为栈指针和基指针来使用的
1. 操作数的三种基本类型：
  * 立即数(Imm)
  * 寄存器值(Reg)
  * 内存值(Mem)。
1. 以movq为例：movq [Imm|Reg|Mem], [Reg|Mem]，第一个是源操作数，第二个是目标操作数
  * movq Imm, Reg -> mov $0x5, %rax -> temp = 0x5;
  * movq Imm, Mem -> mov $0x5, (%rax) -> *p = 0x5;
  * movq Reg, Reg -> mov %rax, %rdx -> temp2 = temp1;
  * movq Reg, Mem -> mov %rax, (%rdx) -> *p = temp;
  * movq Mem, Reg -> mov (%rax), %rdx -> temp = *p;
  * movq Mem, Mem，这种情况不存在，不能用一条指令完成内存间的数据交换
1. 上面的例子中，操作数带括号表示寻址，分两种情况：
  * (R)，指寄存器 R 保存的是一个内存地址，类似C语言的指针，movq (%rcx), %rax 也就是说以 %rcx 寄存器中存储的地址去内存里找对应的数据，存到寄存器 %rax 中
  * D(R)，D是偏移量，movq 8(%rbp),%rdx 也就是说以 %rbp 寄存器中存储的地址再加上 8 个偏移量去内存里找对应的数据，存到寄存器 %rdx 中
  * D(Rb, Ri, S)，表示内存地址是Rb + Ri * S + D。其中：
    1. D - 常数偏移量
    1. Rb - 基寄存器
    1. Ri - 索引寄存器，不能是 %rsp
    1. S - 系数
1. 举例说明，假设 %rdx 中的存着 0xf000，%rcx 中存着 0x0100，那么：
  * 0x8(%rdx) = 0xf000 + 0x8 = 0xf008
  * (%rdx, %rcx) = 0xf000 + 0x100 = 0xf100
  * (%rdx, %rcx, 4) = 0xf000 + 4*0x100 = 0xf400
  * 0x80(, %rdx, 2) = 2*0xf000 + 0x80 = 0x1e080
1. 以leaq Src, Dst为例，leaq (%rdi, %rdi, 2), %rax 表示%rdi * 3，再把值给%rax
1. 需要两个操作数的指令：
  * addq Src, Dest -> Dest = Dest + Src
  * subq Src, Dest -> Dest = Dest - Src
  * imulq Src, Dest -> Dest = Dest * Src
  * salq Src, Dest -> Dest = Dest << Src，左移Src位
  * sarq Src, Dest -> Dest = Dest >> Src，右移Src位（算术右移）
  * shrq Src, Dest -> Dest = Dest >> Src，右移Src位（逻辑右移）
  * xorq Src, Dest -> Dest = Dest ^ Src，取或
  * andq Src, Dest -> Dest = Dest & Src，取与
  * orq Src, Dest -> Dest = Dest | Src，取非
1. 需要一个操作数的指令：
  * incq Dest -> Dest = Dest + 1
  * decq Dest -> Dest = Dest - 1
  * negq Dest -> Dest = -Dest
  * notq Dest -> Dest = ~Dest  
  