### 异常控制流 - 不同进程间的切换与沟通

#### 逻辑控制流
1. 跳转(goto)和分支(if 和switch)
1. 调用和返回(函数调用)

#### 系统调用示例
1. 用户调用了 open，系统实际上会执行 __open 函数，也就是进行系统调用 syscall（open 是编号 2 的系统调用）
1. 对应的汇编代码是mov $0x2, %eax和syscall，返回值存在%rax中，如果为负数，则是出错
1. 如果定义int a[1000]，访问a[5000]，内核执行时会向用户进程发送 SIGSEGV 信号，用户进程会以 segmentation fault 的标记退出

#### 异常控制流
1. 底层异常(Exception)，由硬件和操作系统共同实现的
  * 异步异常（也称中断），因为不知道什么时候会发生。CPU对其的响应也完全是被动的，但是可以屏蔽掉。常见的中断有两种：
    1. 计时器中断：是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。
    1. I/O 中断：类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕
  * 同步异常，执行某条指令所导致的事件，分为陷阱(Trap)、故障(Fault)和终止(Abort)三种情况
1. 进程切换(Process Context Switch)，可以看做是一个从硬件过渡到操作系统，再从操作系统过渡到语言库的过程
1. 信号(Signal)，可以看做是一个从硬件过渡到操作系统，再从操作系统过渡到语言库的过程
1. 非本地跳转(Nonlocal Jumps)， 由C 运行时库中实现

