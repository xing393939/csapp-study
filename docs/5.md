### 异常控制流 - 不同进程间的切换与沟通

#### 逻辑控制流
1. 跳转(goto)和分支(if 和switch)
1. 调用和返回(函数调用)

#### 系统调用示例
1. 用户调用了 open，系统实际上会执行 __open 函数，也就是进行系统调用 syscall（open 是编号 2 的系统调用）
1. 对应的汇编代码是mov $0x2, %eax和syscall，返回值存在%rax中，如果为负数，则是出错
1. 如果定义int a[1000]，访问a[5000]，内核执行时会向用户进程发送 SIGSEGV 信号，用户进程会以 segmentation fault 的标记退出

#### 异常控制流
1. 底层异常(Exception)，由硬件和操作系统共同实现的
  * 异步异常（也称中断），因为不知道什么时候会发生。CPU对其的响应也完全是被动的，但是可以屏蔽掉。常见的中断有两种：
    1. 计时器中断：是由计时器芯片每隔几毫秒触发的，内核用计时器终端来从用户程序手上拿回控制权。
    1. I/O 中断：类型比较多样，比方说键盘输入了 ctrl-c，网络中一个包接收完毕
  * 同步异常，执行某条指令所导致的事件，分为陷阱(Trap)、故障(Fault)和终止(Abort)三种情况
1. 进程切换(Process Context Switch)，可以看做是一个从硬件过渡到操作系统，再从操作系统过渡到语言库的过程
  * 切换进程时，内存中需要另一块区域来保存当前的寄存器值，以便下次执行的时候进行恢复（也就是所谓的上下文切换）
1. 信号(Signal)，可以看做是一个从硬件过渡到操作系统，再从操作系统过渡到语言库的过程
  * 需要注意进程有一个 SIGCHLD 信号处于等待状态，那么之后进来的 SIGCHLD 信号都会被直接扔掉。
  * 信号处理器：每个信号类型都有一个预定义的默认动作，也可以自定义一个信号处理器。信号处理器也可以被其他的信号处理器中断。所有的上下文切换都是通过调用某个异常处理器完成的。
  * 异步信号安全函数是指：
    1. 所有的变量都保存在栈帧中的函数
    1. 不会被信号中断的函数
  * Posix 标准指定了 117 个异步信号安全的函数  
1. 非本地跳转(Nonlocal Jumps)， 由C 运行时库中实现
  * 本地跳转：goto语句，不能从一个函数跳转到另一个函数中
  * 非本地跳转：
    1. int setjmp(jmp_buf env) 保存当前程序的堆栈上下文环境，仅在调用setjmp的函数内有效
    1. void longjmp(jmp_buf env, int val) 将会恢复由 setjmp 保存的程序堆栈上下文，即程序从调用 setjmp 处重新开始执行。传val将体现在setjmp的返回值上
    1. longjmp 的时候，函数必须在栈中（也就是还没完成）才可以进行跳转。如果函数已经完成，对应的栈帧在内存中已经被清理，则不能跳转。

