### 链接

#### C 语言的编译过程
1. 预处理器：将 C 语言代码(da.c)转化成 da.i 文件(gcc –E)
1. 编译器：C 语言代码(da.c, wang.c)经过编译器的处理(gcc -S)成为汇编代码(da.s, wang.s)
1. 汇编器：汇编代码(da.s, wang.s)经过汇编器的处理(gcc 或 as)成为对象程序(da.o, wang.o)
1. 链接器：对象程序(da.o, wang.o)以及所需静态库(lib.a)经过链接器的处理(gcc 或 ld)最终成为计算机可执行的程序
1. 加载器：将可执行程序加载到内存并进行执行，loader 和 ld-linux.so  

#### 编译器将高级语言指令转换为功能等效的汇编代码
1. 源文件的编译过程包含两个主要阶段
1. 第一个阶段是预处理阶段：
  * 宏定义指令，如 #define a b 这种伪指令，预编译所要做的是将程序中的所有 a 用 b 替换，但作为字符串常量的 a 则不被替换。还有 #undef，则将取消对某个宏的定义，使以后该串的出现不再被替换
  * 条件编译指令，如 #ifdef, #ifndef, #else, #elif, #endif等。预编译程序将根据条件判断，将那些不必要的过滤掉
  * 特殊符号，预编译程序可以识别一些特殊的符号。例如在源程序中出现的 LINE 标识将被解释为当前行号（十进制数），FILE 则被解释为当前被编译的C源程序的名称
  * 头文件包含指令，如 #include "FileName" 。该指令将头文件中的定义统统都加入到它所产生的输出文件中，以供编译程序对之进行处理
    1. 所有头文件的搜寻会从 gcc -I 开始
    1. 然后找环境变量 C_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJC_INCLUDE_PATH 指定的路径
    1. 再找默认目录(/usr/include, /usr/local/include, /usr/lib/gcc-lib/i386-linux/2.95.2/include 等等)
1. 第二个阶段编译、优化阶段：通过词法分析和语法分析，翻译成等价的中间代码表示或汇编代码。

#### 链接器主要做两件事情
1. 第一步：符号解析。代码中声明的变量及函数，之后会调用的变量及函数，所有的符号声明都会被保存在符号表(symbol table)
  * 链接器实际上会处理三种不同的符号，对应于代码中三种不同写法：
  * 全局符号 Global symbols：在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量
  * 外部符号 External symbols：同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用
  * 本地符号 Local symbols：在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量
1. 第二步：重定位。把原先分开的代码和数据片段（多个.o文件）汇总成一个文件

#### 对象文件(Object File)有三种形式
1. 可重定位目标文件 Relocatable object file (.o 文件)
1. 可执行目标文件 Executable object file (a.out 文件)
1. 共享目标文件 Shared object file (.so 文件)

#### 对象文件的ELF格式组成
1. ELF header：包含 word size, byte ordering, file type (.o, exec, .so), machine type
1. Segment header table：包含 page size, segments(sections), segment sizes
1. .text section：代码部分
1. .rodata section：只读数据部分，例如跳转表
1. .data section：初始化的全局变量
1. .bss section：未初始化的全局变量
1. .symtab section：包含 symbol table, procudure 和 static variable names 以及 section names 和 location
1. .rel.txt section：.text section 的重定位信息
1. .rel.data section：.data section 的重定位信息
1. .debug section：包含 symbolic debugging (gcc -g) 的信息
1. Section header table：每个 section 的大小和偏移量

